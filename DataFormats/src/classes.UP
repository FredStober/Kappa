#!/usr/bin/env python
import glob, os

"""This file generates the following files in order to register all classes:
   - DataFormats/interface/KDebug.h (DebugH, Kappa header for KDebug.cpp)
   - DataFormats/interface/Kappa.h (KappaH, Kappa TypeName registry)
   - classes.h (ClassesH dict header)
   - classes_def.xml (LCGDict, LCG dictionary header)
   - LinkDef.h (linkdef, linking header)

   These files have code snippet classes below that can be adapted.
"""

def main(inputfile='classes.md', debugcpp='../test/KDebug.cpp'):
	# get includes
	includes = [os.path.basename(h) for h in sorted(glob.glob('../interface/*.h'))
		if os.path.basename(h) not in ['KDebug.h', 'Kappa.h']]

	# get debug functions
	debuglines = []
	classesWithDebugOutput = []
	for line in open(debugcpp, 'r'):
		if line.startswith('std::ostream'):
			if 'operator<<' in line:
				classname = line.split('const')[1].split('&')[0].strip()
				classesWithDebugOutput.append(classname)
			debuglines.append(line.replace('\n', ';'))

	# open output files and write headers (debug must be first)
	files = [DebugH(), DebugTest(), KappaH(), LCGDict(), ClassesH(), LinkdefH()]
	for f in files:
		f.file = open(f.filename, 'w')
		if f.note:  # it is a C++ file that understands comments
			f.write('/* %s\n    %s\n*/\n' % (f.note, f.__doc__ or f.filename))
		f.write(f.header)
		for i in includes:
			f.write(f.includeStr.format(include=i))
		f.write(f.interStr)

	# write debug header (files[0])
	for line in debuglines:
		files[0].write(line)

	# parse input file and write to output files per line
	for textline in open(inputfile, 'r'):
		# parsing rules:
		if not textline or textline[0] not in '+-#':  # read only class or heading lines
			continue

		heading = False
		classes = False
		line = textline.replace(",", "").strip()
		if '#####' in line:  # lines with many ##### go to headings
			heading = line.replace('#', '').strip()
		if line[0] in '+-':  #- or + lines contain classes (- is only written to Linkdef)
			classes = line.replace('+','').replace('-', '').split()

		# now the line is  parsed and all information is gathered
		if classes and len(classes) not in [0, 1, 2]:
			raise IOError("Bad number of classes per line: %d! (classes: %s, line: %s)" % (len(classes), " ".join(classes), line))

		# write in output files
		for f in files:
			if heading:
				f.write(f.headingStr.format(heading=heading))
			if not classes:
				continue
			if line[0] == '+':  # Kappa class
				if classes[0][0] == 'K':  # Kappa class
					if classes[0] in classesWithDebugOutput or 'testDebug' not in f.filename:
						f.write(f.singleStr.format(single=classes[0], fmt='struct'))
				else:
					f.write(f.singleStr.format(single=classes[0], fmt='typedef'))
				if len(classes) == 2:  # vector Kappa class
					f.write(f.vectorStr.format(single=classes[0], vector=classes[1]))
				if files.index(f) == 0 and classes[0] not in classesWithDebugOutput:
					print "No debug output for: %s!" % classes[0]
			if line[0] == '-' and 'linkdef' in f.filename.lower():
				f.write(f.rootStr.format(single=classes[0], fmt='typedef'))
			elif line[0] == '-' and 'interface' not in f.filename and 'testDebug' not in f.filename:
				f.write(f.singleStr.format(single=classes[0], fmt='typedef'))

	for f in files:
		f.write(f.footer)


# File settings:

class BaseFile:
	"""Base class for file handling
	
	Each file is written by adding the header, lines for classes and the footer.
	"""
	filename = ""
	note = """This file is autogenerated by classes.UP. Do not edit!

    Copyright (c) 2010 - 2015, All Rights Reserved
    The authors are listed in the AUTHORS file.
"""
	includeStr = ""
	singleStr = ""   # templates containing {single}
	vectorStr = ""   # templates containing {single} and {vector}
	typedefStr = ""
	headingStr = ""  # templates containing {heading}
	header = ""
	interStr = ""
	footer = ""
	def write(self, string):
		if not hasattr(self, 'file'):
			raise IOError("Can not write. No file open. Filename: %s" % file.filename)
		if string:
			self.file.write(string + '\n')


class KappaH(BaseFile):
	"""Header file of the Kappa data format"""
	filename = '../interface/Kappa.h'
	includeStr = '#include "{include}"'
	singleStr = 'REGISTER_NAME_OF_TYPE({single},{single});'
	vectorStr = 'REGISTER_NAME_OF_TYPE({vector},std::vector<{single}>);'
	header = "#ifndef KDATAFORMAT_H\n#define KDATAFORMAT_H\n"
	interStr = """
template<typename T>
struct TypeName;

#define REGISTER_NAME_OF_TYPE(X,Y)     \\
	template<> struct TypeName<X>      \\
	{                                  \\
		static const char *name()      \\
		{                              \\
			return (#X);               \\
		}                              \\
		static const char *long_name() \\
		{                              \\
			return (#Y);               \\
		}                              \\
	}                                  \\

"""
	footer = "\n#endif"


class DebugH(BaseFile):
	filename = '../interface/KDebug.h'
	header = """\
#ifndef KAPPA_DEBUG_H
#define KAPPA_DEBUG_H

#include <iostream>
#include "Kappa.h"
"""
	footer = '\n#include "KDebug.hxx"\n\n#endif'


class DebugTest(BaseFile):
	"""Standalone script to test the debug outputs of Kappa

    compile with
    g++ testDebug.cc $(root-config --cflags) $(root-config --ldflags --libs) -I../.. -o testdebug  -L../../lib -lKappa -lGenVector"""
	filename = '../test/testDebug.cc'
	header = """\
#include "DataFormats/interface/KDebug.h"
#include <iostream>

using namespace std;

int main() {
	cout << "Kappa object debug output:" << endl;"""
	singleStr = '\tcout << "* {single}: " << {single}() << endl << endl;'
	footer = '}'


class LCGDict(BaseFile):
	"""LCG dictionary used for writing with CMSSW while skimming"""
	note = False
	filename = "classes_def.xml"
	singleStr = '\t<class name="{single}"/>'
	vectorStr = '\t<class name="{vector}"/>'
	header = "<lcgdict>"
	footer = "</lcgdict>"


class ClassesH(BaseFile):
	"""ROOT dictionary that Kappa uses for reading the Kappa skim

	http://root.cern.ch/drupal/content/selecting-dictionary-entries-linkdefh
	http://root.cern.ch/drupal/content/interacting-shared-libraries-rootcint"""
	filename  = 'classes.h'
	includeStr = '#include "../interface/{include}"'
	singleStr = '\t\t{single} dict_{single};'
	vectorStr = '\t\t{vector} dict_{vector};'
	interStr  = '\nnamespace\n{\n\tstruct dictionary\n\t{'
	header    = """\
#ifndef KDATAFORMAT_CLASSES_H
#define KDATAFORMAT_CLASSES_H

#define G__DICTIONARY
"""
	footer = "\t};\n}\n\n#endif"


class LinkdefH(BaseFile):
	filename = "../test/LinkDef.h"
	headingStr = "\n/* {heading} */"
	rootStr = '\n#pragma link C++ {fmt} {single};'
	singleStr = '\n#pragma link C++ {fmt} {single}+;'
	vectorStr = '#pragma link C++ class std::vector<{single}>+;\n#pragma link C++ typedef {vector};'
	header = """\
#include "../src/classes.h"

#ifdef __CINT__

#pragma link off all globals;
#pragma link off all classes;
#pragma link off all functions;

/************************************************************/
/* BASIC AND ROOT OBJECTS                                   */
/************************************************************/

/* Classes already defined by ROOT:
   double Lorentz vector:
     ROOT::Math::PtEtaPhiM4D<double>+
     ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >+
   map used by provenance etc.:
     std::map<std::string, int>+;
   matices (used by MET etc.):
   (and accordingly for 3 and 7 dimensions instead of 2 for these classes):
     ROOT::Math::RowOffsets<2>+
     ROOT::Math::MatRepSym<double,2>+
     ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >+
*/

#pragma link C++ class ROOT::Math::PtEtaPhiM4D<float>+;
#pragma link C++ class ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<float> >+;

#pragma link C++ class ROOT::Math::Cartesian3D<float>+;
#pragma link C++ class ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float> >+;
#pragma link C++ class ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<float>, ROOT::Math::DefaultCoordinateSystemTag>+;

#pragma link C++ class ROOT::Math::SymMatrixOffsets<2>+;
#pragma link C++ class ROOT::Math::SymMatrixOffsets<3>+;
#pragma link C++ class ROOT::Math::SymMatrixOffsets<7>+;

#pragma link C++ class std::vector<std::vector<size_t> >+;

#pragma link C++ typedef RMPoint;
"""
	footer = '#endif'


if __name__ == "__main__":
	main()
